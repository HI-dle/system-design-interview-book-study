# 유튜브 설계

> 안녕하세요, 설계 마스터 최진영입니다.
 
`비디오 업로드 절차`와 `비디오 스트리밍 절차`에 대해 발표하겠습니다.

## 비디오 업로드 절차

### 비디오 업로드 컴포넌트에 대해
아래 그림은 `비디오 업로드 절차`의 개략적 설계안입니다.  설게안의 컴포넌트들이 어떤 역할을 하는 지, 살펴보도록 하겠습니다.

![image_14-4.png](image%2Fimage_14-4.png)

- `사용자`: 컴퓨터나 모바일 폰, 혹은 스마트 TV를 통해 유튜브를 시청하는 이용자
- `로드밸런서`: API 서버 각각으로 고르게 요청을 분산하는 역할을 담당
- `API 서버`: 비디오 스트리밍을 제외한 다른 모든 요청을 처리
- `메타데이터 데이터베이스`: 비디오의 메타데이터를 보관
- `메타데이터 캐시`: 성능을 높이기 위해 비디오 메타데이터와 사용자 객체를 캐싱
- `원본 저장소`: 원본 비디오를 보관할 대형 이진 파일 저장소(BLOB)
- `트랜스코딩 서버`: 비디오의 포멧을 변환하는 절차를 수행(인코딩). 단말이나 대역폭 요구사항에 맞는 최적의 비디오 스트림을 제공하기 위해 필요
- `트랜스코딩 비디오 저장소`: 트랜스코딩이 완료된 비디오를 저장하는 BLOB 저장소
- `CDN`: 비디오를 캐시하는 역할을 담당, 사용자가 재생 버튼을 누르면 비디오 스트리밍은 CDN을 통해 이루어짐
- `트랜스코딩 완료 큐`: 비디오 트랜스코딩 완료 이벤트들을 보관할 메시지 큐
- `트랜스코딩 완료 핸들러`: 트랜스코딩 완료 큐에서 이벤트 데이터를 꺼내어 메타데이터 캐시와 메타데이터 데이터베이스를 갱신할 작업 서버들

### 비디오 업로드 절차는 어떻게 되는가?
각 컴포넌트가 무슨 일을 하는지는 살펴보았으니, 비디오 업로드가 어떻게 처리되는지를 알아보겠습니다.

아래의 두 프로세스가 병렬적으로 수행된다고 보면 되겠습니다.
- 비디오 업로드
- 비디오 메타데이터 갱신(메타데이터에는`비디오 URL 크기, 해상도, 포멧, 사용자 정보`가 포함됩니다.)

> 아래 그림과 같이 `비디오 업로드`는 프로세스 A, `비디오 메타데이터 갱신`은 프로세스 B라고 봐주시면 되겠습니다.
> 
> 이 두 프로세스가 병렬적으로 수행된다!

![image_14-5.png](image%2Fimage_14-5.png)

먼저, `비디오 업로드` 프로세스의 절차부터 보겠습니다.

![image_14-5-2.png](image%2Fimage_14-5-2.png)

> 이건 발표 준비를 하면서 헷갈렸던 부분입니다.
> 
> (1)번 화살표를 보면, 사용자 단말에서 원본 저장소를 바로 찌르고 있는 것이 의문이였는데요.
> 
> GPT에게 물어본 결과,
> 
> 단말이 API 서버에 `비디오 업로드 요청`을 하면, API 서버는 사용자 단말이 직접 AWS S3와 같은 저장소에 접근할 수 있도록하는 URL을 발급해준다고 합니다.
> 
> 해당 URL을 받은 단말은 직접 `원본 저장소`에 비디오를 업로드하게 됩니다.
> 
> 업로드가 완료되면, 단말은 API 서버에 `업로드 완료`를 알리게되고, 이 때 트랜스코딩 서버가 `인코딩`을 합니다.
> 
> 나머지 절차는 그대로 이루어지고, 모든 준비가 끝나면 API서버는 단말에게 `스트리밍 준비가 완료`되었다고 알려줍니다.

---

그럼 다음으로는 프로세스 B인 `비디오 메타데이터 갱신` 절차를 살펴보겠습니다.

메타데이터라 함은, `파일 이름, 크기, 포맷` 등의 정보가 포함됩니다.

프로세스 A의 과정인, `단말이 원본 저장소에 비디오 파일을 업로드하는 과정`이 진행되는 동안 단말은 병렬적으로 비디오 메타데이터 갱신 요청을 API 서버에 보냅니다.
> 여기서도 의문이 들었습니다
> 
> 🤔 왜 프로세스 A에서도 결국 업로드가 끝나면 메타데이터를 갱신할텐대, 업로드하는 동안 메타데이터 갱신 요청을 주기적으로 보내는걸까?
> 
> 프로세스 B에서 업로드 도중 메타데이터를 지속적으로 갱신하는 이유는, 업로드 도중 네트워크 문제로 실패하거나, 사용자가 업로드 도 중 창을 끈다던가했을 때, 진행도를 저장하기 위함입니다.
> 
> 즉, 업로드 중간 상태를 추적함으로써, 재시도와 같은 서비스를 제공해서 사용자 편의성을 올릴 수 있게됩니다.

절차 그림은 아래와 같습니다.

![image_14-6.png](image%2Fimage_14-6.png)

## 비디오 스트리밍 절차
유튜브에서 비디오 재생버튼을 누르면 스트리밍은 바로 시작되며 비디오 다운로드가 완료되어야 영상을 볼 수 있다거나 하는 불편함은 없습니다.
- `다운로드`: 비디오를 단말로 내려 받는 것
- `스트리밍`: 단말이 원격지의 비디오로부터 지속적으로 비디오 스트림을 전송 받아 영상을 재생하는 것

우리는 절차를 보기 전에, `스트리밍 프로토콜`이라는 중요한 개념을 알아두어야 합니다.

스트리밍 프로토콜은 비디오 스트리밍을 위해 데이터를 전송할 때 쓰이는 표준화된 통신 방법입니다.

널리 사용되는 프로토콜로는 다음과 같은 것들이 있습니다.
- MPEG-DASH
  - MPEG(Moving Picture Experts Group)
  - DASH(Dynamic Adaptive Streaming over HTTP)
- 애플의 HLS(HTTP Live Streaming)
- 마이크로소프트 스무드(Smooth) 스트리밍
- 어도비 HTTP 동적 스트리밍(Adobe HDS)

> 책에서는 프로토콜의 동작 원리를 정확하게 이해하거나, 외울 필요는 없다고 합니다. 확실히 이해하려면 관련 분야의 도메인 지식을 알아야하기 때문이라고해요.

중요하게 알아야할 점은, 프로토콜마다 지원하는 비디오 인코딩이 다르고 플레이어도 다르다는 것입니다.
떠러서, 비디오 스트리밍을 설계할 때는 `서비스의 용례에 맞는 프로토콜`을 잘 골라야합니다.

그럼 마지막으로 비디오 스트리밍 개략적 설계안을 그림으로 간단하게 보겠습니다.

![image_14-7.png](image%2Fimage_14-7.png)

앞서 얘기드렸 듯, 비디오는 CDN에서 바로 스트리밍되는데, 사용자의 단말에 가장 가까운 `CDN 엣지 서버(edge server)`가 비디오 전송을 담당할 것입니다.
> **CDN 엣지 서버**
> 
> CDN (Content Delivery Network)의 일부로, 사용자와 가까운 위치에 존재하면서 정적 콘텐츠(비디오, 이미지, JS, CSS 등)를 캐싱하고 제공하는 서버

따라서 전송 지연은 아주 낮습니다.

## 하온님의 질문
`널리 사용되는 스트리밍 프로토콜들이 HTTP 프로토콜 위에서 동작하는 듯 한데, 그럼 UDP가 아닌 TCP 위에서 동작하는 것인지, 맞다면 어떻게 빠른 속도로 스트림 데이터를 전송할 수 있는 걸까요?`

일단 자료를 찾아본 결과, 넷플릭스도 UDP가 아닌 TCP를 사용하고 있다고합니다.

제가 생각하기로는 여전히 UDP가 TCP보다는 빠를 것이라고 생각하는데요.

그리고 저희가 초점을 두어야할 부분은, 아래 두 가지라고 생각했습니다.
- 넷플릭스는 TCP의 어떤 장점때문에 속도를 조금 포기하더라도 TCP를 선택했을까?
- TCP를 사용함으로써 속도 최적화는 어떻게 할 수 있었을까?

### UDP 대신 TCP를 사용하는 이유
- 신뢰성 있는 데이터 전송
  - 비디오 재생 중 프레임이 깨지거나 누락되는 문제 방지
- 패킷 손실 보정 가능
  - 고화질 스트리밍은 일부 패킷 손실만으로도 큰 품질 저하 발생 -> TCP는 이를 자동 보정
- 방화벽/NAT 통과 용이
  - TCP는 대부분의 네트워크 환경(회사, 학교, 공공 Wifi)에서도 그냥 작동함
-  CDN, 브라우저, 인프라와의 높은 호환성
  - TCP는 CDN 캐싱, 브라우저 통신, HTTP/2/3 지원과 잘 맞아서 글로벌 확장이 쉽다
- 실시간성보다 안정성이 더 중요
  - 넷플릭스는 VOD(사용자가 원하는 시간에 원하는 영상을 골라 볼 수 있는 서비스).
  - 초저지연(데이터 전송 시간이 매우 짧은 것)보다 끊김 없는 고품질 재생이 핵심
- TCP는 송신자와 수신자 사이의 대역폭을 측정하기 쉽다.
  - 비디오 품질 자동 조절
    - 적절한 버퍼링 활용 or 화질 조정

### TCP를 사용함으로써 속도 최적화는 어떻게 할 수 있었을까?
일단 버퍼링을 최적화하기 위해, 영상 시작 전에 10초 분량 데이터를 먼저 다운로드한다고 합니다.

또한 CDN 엣지 서버를 통해 지연을 최소화하고, HTTP/2의 멀티플렉싱, 헤더 압축 등으로 전송을 최적화한다고 합니다.

그리고 `TCP Fast Open`이라는 것도 있는데, 3-way 핸드셰이크를 캐싱하는 느낌으로, 초기 연결 시 TFO라는 쿠키를 클라이언트 측에 저장합니다.

나중에 다시 연결 시, 해당 쿠키와 함께 SYN 패킷을 보내게 되고, 성공하게 되면 3-way 핸드셰이크의 최종 ACK 패킷을 수신하기 전에도 클라이언트로 데이터를 보내기 시작할 수 있다고 합니다.

### 추가 내용
찾아보니 하온님 말씀처럼 실시간성이 완전 중요한, 즉, zoom이나 구글 밋 같은 사용자가 서로 즉각 듣고 반응해야하는 환경에서는 UDP 기반 프로토콜을 사용하는 것 같습니다.(e.g WebRTC)

반면 트위치나 유튜브의 라이브 스트리밍과 같은 경우는 물론 라이브이긴하지만, 아주 약간은 딜레이가 있어도 되는 경우는 TCP를 활용하는 것 같습니다.(안정성이 더 중요하기 때문)

> 다음으로는 설계의 갓 오브 갓 지은갓이 상세 설계부터 발표라는 은총을 선사해주실 예정입니다.