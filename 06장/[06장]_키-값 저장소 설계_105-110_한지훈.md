# 대규모 시스템 키-값 저장소 장애 처리

---



## 장애 감지

 - 분산 시스템에서 한 대 서버(A 서버)가 죽는 상황이 있을 때 바로 A 서버를 장애 처리하지 않는다. 보통 두 대 이상의 서버에서 A 서버의 장애를 보고해야 해당 서버가 실제로 장애가 발생했다 간주해 처리하게 된다.

![image_6-10.png](image%2Fimage_6-10.png)


 - 위 구성처럼 서버가 구성되어 있을 때 모든 노드 사이 멀티캐스팅 채널을 구축하는 것이 장애를 감지하는 가장 쉬운 방법이다. 하지만 서버가 점점 많아질수록 비효율적이게 된다.

 - 분산 시스템에서 가십 프로토콜(gossip protocol) 같은 분산형 장애 감지 솔루션을 채택하면 효율적이게 된다.



## 가십 프로토콜

 - 분산 환경에서 메시지를 전달하는 커뮤니케이션 방식의 하나이다.

 - 외국에서는 바이러스가 퍼지는 방식으로 동작한다하여 Epidemic Protocol과 동의어로 사용되기도 한다고 한다.



### 가십 프로토콜 동작 방식

1. 각 노드는 멤버십 목록을 유지한다. 멤버십 목록은 멤버 ID와 그 박동 카운터 쌍의 목록이다.

2. 각 노드는 주기적으로 자신의 박동 카운터를 증가시킨다.

3. 각 노드는 무작위로 선정된 노드들에게 주기적으로 자기 박동 카운터 목록을 보낸다.

4. 박동 카운터 목록을 받은 노드는 멤버십 목록을 최신 값으로 갱신한다.

5. 어떤 멤버의 박동 카운터 값이 지정된 시간 동안 갱신 되지 않으면 해당 멤버는 장애 상태인 것으로 간주한다.

![image_6-11.png](image%2Fimage_6-11.png)



````
노드 s0은 테이블의 멤버십 목록 값을 가진다.

노드 s0은 노드 s2(멤버 아이디 = 2)의 박동 카운터가 오랫동안 오르지 않은 것을 확인한다.

노드 s0은 노드 s2를 포함해 박동 카운터 목록을 무작위 노드들에게 전달한다.

노드 s2의 박동 카운터가 오랫동안 증가 되지 않았음을 발견한 모든 노드들은 해당 노드(s2)를 장애 노드로 표시한다.
````


### 일시적 장애 처리

 - 가십 프로토콜로 장애를 감지한 시스템은 가용성을 보장하기 위해 필요한 조치를 해야한다. 엄격한 정족수(strict quorum) 접근법을 쓴다면 읽기와 쓰기 연산을 금지해야 한다.

 - 느슨한 정족수 접근법은 이 조건을 완화해 가용성을 높인다. 정족수 요구사항을 강제하는 대신 쓰기 연산을 수행할 W개의 건강한 서버와 읽기 연산을 수행할 R개의 건상한 서버를 해시 링에 고른다. 이때 장애 상태인 서버는 무시한다.

 - 네트워크나 서버 문제로 장애 상태인 서버로 가는 요청은 다른 서버가 맡아 처리한다. 그동안 발생한 변경사항은 해당 서버가 복구될 때 일괄 반영해 데이터 일관성을 보존한다. 이를 위해 임시로 쓰기 연산을 처리한 서버에는 그에 관한 단서인 hint를 남겨둔다.

이런 장애 처리 방안을 단서 후 임시 위탁 기법이라 부른다.

![image_6-12.png](image%2Fimage_6-12.png)


 - 위 그림에서 장애 상태인 s2에 대한 읽기와 쓰기 연산은 일시적으로 노드 s3가 수행한다. 장애 노드가 복구되면 s3은 갱신된 데이터를 s2에 저장하게 되는 것이다.





### 영구 장애 처리

 - 단서 후 위탁 기법은 일시적 장애를 처리하기 위한 것으로 영구적인 노드의 장애 상태는 반-엔트로피(anti-entropy) 프로토콜을 구현해 사본들을 동기화할 것이다.

 - 반-엔트로피 프로토콜은 사본들을 비교해 최신 버전으로 갱신하는 과정을 포함한다. 사본 간 일관성이 망가진 상태를 탐지해 전송 데이터의 양을 줄이기 위해 머클(merkle) 트리를 사용할 것이다.

 - 머클 트리란 해시 트리라고도 불린다. 머클 트리는 각 노드에 그 자식 노드들에 보관된 값의 해시(자식 노드가 리프 노드일 경우) 또는 자식 노드들의 레이블로부터 계산된 해시 값을 레이블로 붙여두는 트리이다. 해시 트리를 사용하면 대규모 자료 구조의 내용을 효과적이고 보안상 안전하게 검증할 수 있다.

 - 키 공간이 1 ~ 12까지일 때 머클 트리를 만드는 예제를 확인해보자. 이때 망가진 데이터가 위치된 곳은 다른 색으로 표시했다.



1 단계 : 키 공간을 아래와 같이 버킷으로 나눈다.

![image_6-13.png](image%2Fimage_6-13.png)


2 단계 : 버킷에 포함된 각각의 키에 균등 분포 해시 함수를 적용해 해시 값을 계산한다.

![image_6-14.png](image%2Fimage_6-14.png)


3 단계 : 버킷별로 해시 값을 계산해 해당 해시 값을 레이블로 갖는 노드를 만든다.

![image_6-15.png](image%2Fimage_6-15.png)


4 단계 : 자식 노드의 레이블로부터 새로운 해시 값을 계산해 이진 트리를 상향식으로 구성한다.

![image_6-16.png](image%2Fimage_6-16.png)


 - 이 두 머클 트리의 비교는 루트 노드의 해시 값을 비교하는 것으로 시작한다.

 - 루트 노드의 해시 값이 일치한다면 두 서버는 같은 데이터를 갖는 것이다. 값이 다른 경우 왼쪽 자식 노드의 해시 값을 비교하고 다음으로 오른쪽 해시 값을 비교한다. 이렇게 아래쪽으로 탐색하다 보면 다른 데이터를 갖는 버킷을 찾을 수 있으므로 그 버킷만 동기화하면 된다.

 - 머클 트리를 사용하면 동기화해야 하는 데이터의 양은 실제로 존재하는 차이의 크기에 비례할 뿐 두 서버에 보관된 데이터의 총량과는 무관하다.



 - 실제 사용되는 시스템인 경우 버킷 하나의 크기가 꽤 크다. 가능한 예시 중 하나로 10억 개의 키를 1,000,000개의 버킷으로 관리하는 것인데 이 경우 하나의 버킷은 1,000개 키를 관리하게 된다.

---
## 정족수
- 정족수 (Quorum)
  - 쿼럼이라 부르는데 쿼럼은 카프카, DB 등 다양한 서비스에서 사용된다.
  - 분산 시스템에서 사용 되는데, 쿼럼은 의사 결정에 필요한 정족수이며 사전적으로는 합의체가 의사를 진행하고 결정 하는데 필요한 최소한의 출석 인원이다.
  - 예시로 스터디 인원 5명 중 오늘 스터디 제끼죠? 할 때 n명이 동의하면 제낄 수 있는 것이다. 이때 n은 1 <= n <= 5 이다.
  - 좁은 의미에서는 어떤 동작을 하기 위해 필요한 최소한의 동등한 어떤 무언가들의 찬성 표 개수를 뜻한다. 넓은 의미에서는 특정 행위를 하기 위해 정족수가 필요하다는 규칙을 가리킨다.
  - 쿼럼은 분산 환경에서 스플릿 브레인(split brain)이나 amnesia 등에서 사용 되는데 amnesia는 노드들이 모두 죽었을 때이며 지금은 스플릿 브레인만 확인하도록 한다.
  - 스플릿 브레인은 클러스터에서 둘 이상의 노드들이 I/O 요청을 처리할 때 충돌이 발생하는 상황을 말하는데 노드 그룹 간 네트워크 연결 단절 등으로 인해 발생할 수 있고 이때 데이터 충돌이나 오염이 발생하기도 한다.
  - 분산 환경에서 slave를 master로 승격 시키거나 서버 하나가 죽어서 다른 서버에 대해 쓰기나 읽기 작업을 금지 시키거나 허용시킬 때 사용된다.
  - 쿼럼이 충족해야할 규칙이 있다.

    - 첫 번째는 read 작업을 하는 노드들과 write를 하는 노드들 중 반드시 최소 하나는 겹쳐야 한다는 것이다. 그래야 일관성을 보장할 수 있다.
![quorum1.png](image%2Fquorum1.png)
    - 위 그림에서 동일한 자원에 대해 노드1,2가 쓰고 3이 읽을 때 데이터 일관성 문제가 발생할 수 있다. 동일 자원에 대해 각 노드가 독립적으로 작업을 수행 한다면 해당 자원에 대해 일관성, 동시성을 보장해야 한다.
    ![quorum2.png](image%2Fquorum2.png)
    - 이번엔 같은 노드 3개 중 노드 2가 쓰기와 읽기에 대해 겹치는 노드의 존재를 보장하는 경우이다.
    - 같은 자원에 대해 다른 노드들에서 읽기와 쓰기 작업을 해도 노드 2가 쓰고 있다는 의사결정으로 인해 읽기 작업을 미룰 수 있다. 이처럼 일관성을 보장한다.
    - 예시로 마치 세 명의 직원이 있는 회사에서 어떤 프로젝트를 두 명이 쓰고 있고, 다른 한 명이 그 프로젝트 내용을 읽으려고 한다. 만약 그 읽으려는 사람이 작성 중인 둘과 아무 교류도 없다면? 전 내용만 읽을 수 있다. 하지만 읽는 사람이 작성 중인 둘 중 한 명과 겹쳐 있다면? 쓰기 작업중이라고 의사표현을 할 수 있기 때문이다.

    - 두번쨰는 쓰기 작업을 할 때 찬성표를 던진 노드들이 반드시 이전 쓰기 동작을 할 때 찬성했던 노드들에 대해 겹치는 노드가 있어야 한다는 것이다.
    - 이걸 만족하면 같은 데이터에 대해 두 개의 Write가 동시에 이뤄져도 충돌 가능성이 줄어든다.
    - 이전 예시와 같이 3개 노드가 있을때 Vw > N / 2 (과반수 초과)를 만족하게 해서 해결한다.
    - 충돌이 나는 예시로 같은 자원에 대해 write A → copy1 + copy2에서 write, 동시에 write B → copy3 + copy2에서 write, 이때 copy2만 겹치고, 서로 다른 내용을 기록한다. 결국 데이터 일관성 깨짐 가능성 생긴다.
    - 과반수 초과를 만족하게 해서 위 충돌 에시에서 copy2가 write B에 참여하려면, 먼저 A가 끝나야 하고 이후 copy3가 찬성해야 write B는 성공할 수 있다.

> 개인적으로 궁금했던 것은 write 시 하나의 노드가 찬성할 수 있는 write는 하나뿐인가? 인데 이떄 하나의 노드가 여러 write 요청에 동시에 찬성할 수도 있습니다,
하지만 그건 시스템의 정책에 따라 다르다. 낙관락, 비관락 처럼 시스템 설계에 따라 다르게 된다. 


출처: https://2kindsofcs.tistory.com/79
AWS: https://aws.amazon.com/ko/blogs/korea/amazon-aurora-under-the-hood-quorum-and-correlated-failure/


--- 

## 가십 프로토콜

 - 컴퓨터 네트워크에서 노드들 간 정보를 분산하는 방식 중 하나로 피어 투 피어(peer-to-peer) 네트워크에서 사용되고 노드들 사이 데이터를 균등히 분산하고 동기화 하는데 사용된다.
 - 가십 프로토콜 동작 방식
   - 정보 전파 : 각 노드는 가까운 이웃 노드에게 자신이 가지고 있는 정보를 전파한다. 이 정보는 새로운 데이터 또는 업데이트된 정보일 수 있다.
   - 선택적 전달 : 가십 프로토콜은 모든 노드에게 정보를 전달하는 것이 아닌 일부 이웃 노드에게만 정보를 전달한다. 이를 통해 네트워크의 부하를 줄이고 효율적인 데이터 분산을 달성할 수 있다.
   - 확산 및 복제 : 노드들이 정보를 받으면 이를 또 다른 이웃 노드에게 전달해 정보가 네트워크 전체로 확산되게 한다. 이 과정을 반복해 모든 노드가 최신 정보를 가지게 된다.
 - 가십 프로토콜은 특히 분산 시스템에서 데이터의 일관성과 동기화를 유지하기 위해 사용된다. 네트워크 전체가 동일한 데이터 상태를 유지해 분산된 데이터베이스나 블록체인의 합의 메커니즘을 지원한다.

## 반 엔트로피 프로토콜

 - 분산 시스템에서 반 엔트로피 프토토콜은 데이터 복사본을 저장하는 서로 다른 노드 또는 복제본 간 일관성과 동기화를 보장하는 데 사용되는 일련의 기술이다.
 - 분산 환경에서 네트워크 지연, 노드 장애 또는 서로 다른 위치에서 이루어진 쓰기 작업으로 인해 불일치가 발생하는 경우가 많은데 이러한 불일치는 시스템에서 엔트로피로 이어지고 이 엔트로피를 줄이고자 등장했다.
 - 반 엔트로피에는 푸시 방법, 풀 방법, 푸시-풀 방법 을 사용하며 머클 트리나 데이터 체크섬을 사용해 데이터 차이만 교환해 성능을 최적화 하는 방법을 사용한다.
 - 반 엔트로피 동작
   - 1. 불일치 감지 : 어떤 노드에서 다르거나 오래된 데이터가 있는지 감지
   - 2. 동기화 시작 : 불일치 감지시 푸시, 풀, 푸시-풀 방법을 사용해 동기화 프로세스 시작
   - 3. 데이터 비교 : 머클 트리를 주로 사용하며, 노드가 해시 값을 교환하고 비교해 데이터에 대해 다른 부분만 전송하는 방식이다.
   - 4. 누락되거나 오래된 데이터 교환 : 노드는 불일치 데이터에 대해 불일치 데이터 부분이나 전체를 보내는 등 데이터를 최신화 하게 한다.
   - 5. 충돌 해결 : 경우에 따라 연결이 끊어진 노드에 대해 서로 다른 업데이트를 가지고 충돌이 발생할 수 있다. 마지막 쓰기 우선이나 버전 벡터를 사용해 최신 데이터 판별이나 데이터 우선권을 주는 방식으로 충돌을 처리해야 한다.
   - 6. 주기적 실행 : 일회성 프로세스가 아니므로 주기적으로 실행돼야 한다. 즉시 일관성이 지켜지지 않더라도 최종 일관성을 지키게 해 일관된 상태로 수렴되게 한다. 실행 빈도나 방법은 일관성이나 가용성에 대한 시스템 요구 사항에 따라 달라질 수 있다.
   - 7. 최종 일관성 : 최종 일관성을 달성하는 것이 목표이며 모든 노드가 동일하고 올바른 버전의 데이터로 수렴하도록 해야한다.

 - 분산 시스템에서 안티 엔트로피 사용 사례에는 분산 데이터베이스의 데이터 복제, Cloud Storage의 내결함성, CDN 일관성, 분산 캐시 시스템, MSA 아키텍처에서 사용된다.
 - 분산 시스템에서 주요 해결 과제는 
   - 네트워크 오버헤드 : 노드 불일치로 많은 데이터 교환에 대해 네트워크 트래픽이 많아지고 전체적인 성능 저하가 발생할 수 있다.
   - 성능 및 대기 시간 : 대규모 데이터 세트를 처리할 때 시간이 걸릴 수 있고, 동기화 시도가 잦으면 작업이 지연될 수 있다. 이는 사용자 경험에 영향을 미친다.
   - 충돌 해결 : 노드에 동일한 버전이 존재할 경우 충돌이 발생하고 충돌에 대해 잘못된 충돌 해결시 데이터 손실, 불일치 등 위험이 발생하고 일관되지 않은 충돌 해결 전략으로 인해 노드가 수렴이 아닌 더 분산될 수 있다.
   - 확장성 : 확장에 따라 복잡성과 리소스 요구가 증가한다. 지속적인 확장은 어려우며 안티 엔트로피를 효율적으로 처리해야 한다.
   - 대규모 데이터 세트 처리 : 노드 간 데이터 비교 후 교환하는 방식이기 때문에 지연, 많은 리소스 사용이 발생한다. 머클 트리로 해소는 하지만 복잡성이 증가하며 매우 큰 데이터 세트의 문제인 경우 완전한 해결점이 아니다.
 - 분산 시스템에서 안티 엔트로피 프로세스를 최적화 하는데 사용할 수 있는 기술과 접근 방식
   - 차등 동기화 : 전체 데이터 세트가 아닌 노드 간 차이만 교환에 중점을 두고 다른 버전의 데이터 간 변경 사항이나 델타만 계산하고 전송하는 데 사용된다.
   - 머클 트리 : 해시 값을 통해 데이터를 비교할 수 있도록 하는 계층 구조
   - 지연 동기화 : 시스템 수요가 많은 기간 동안 성능과 가용성의 우선 순위를 지정하고 어떤 프로세스를 지연 시켜 지연 동기화를 진행한다.
   - 가십 프로토콜 : 시스템이 중앙 집중식 동기화에 의존하지 않고 통신이 점진적으로 발생한다. 어떤 노드가 다른 노드에 대해 무작위로 통신하고 데이터를 교환한다.
   - 벡터 시계 : 데이터 버전을 추적해 충돌을 감지하는 것으로 vector clocks를 통해 필요한 데이터만 교환한다.
   - 적응형 안티 엔트로피 주파수 : 고정된 간격으로 안티 엔트로피를 실행하는 대신 시스템은 적응형 안티 엔트로피를 채택해 네트워크 부하, 노드 활동 또는 데이터 수정 속도와 같은 요인에 따라 동기화 빈도를 조정
 - 안티 엔트로피는 분산 시스템에서 데이터 일관성을 유지하기 위한 메커니즘이고 노드간 다른 위치에 분산되어 있을 때 중요하다.
 - 안티 엔트로피는 클라우트 스토리지 및 데이터베이스와 같은 실제 애플리케이션에서 사용되는 내결함성, 확장 가능하고 신뢰 가능한 분산 시스템을 구축하는 데 필수적이다.

출처 : https://www.geeksforgeeks.org/anti-entropy-in-distributed-systems/

## 머클 트리

 - 머클 트리, 해시 트리의 목적은 데이터의 간편하고 확실한 인증을 위해 사용되며, 최상위 노드를 루트 혹은 머클 루트라 부른다.
 - 머클 트리에서는 보통 SHA-256 해시 함수를 사용한다. 
 - 데이터를 여러 조각으로 나누며 생성된다. 머클 루트를 형성하기 위해서는 반복적인 해시화가 된다.
 - 노드가 전체 데이터가 아닌 데이터셋 간 차이만 비교해 교환할 수 있도록 하고 루트 해시를 비교함으로 데이터의 어떤 부분이 다른가를 빠르게 식별해 전송되는 데이터 양을 줄인다.
> SHA-256은 단방향 암호화 기술로 암호화된 결과는 16진수이며 크기는 고정된 64자이다.

![mercle1.png](image%2Fmercle1.png)
 - 원래 64자로 표현해야 하지만 간단히 4자로 표현.
 - 블록 체인에서 머클 트리가 많이 사용된다. 
 - 각 트랜잭션(TX1...)들을 SHA-256을 통해 64자 해시 결과를 만들고 인접한 노드를 합하고 다시 SHA-256 암호화해 해시 결과를 만들어 최종적으로 1개의 해시가 나올때까지 반복한다.
 - 모든 해시 값은 이전 값에 대한 해시 값을 가지기 때문에 하나라도 다르다면 최종 결과인 머클 루트가 달라지게 된다.
 - 머클 트리에서 풀 노드와 라이트 노드의 개념이 있고, 풀 노드는 지금까지의 블록이고 즉, 전체를 가지고 유지하는 노드이다. 라이트 노드는 전체가 아닌 몇몇 블록만 가진 풀 노드에게 필요한 정보만 받아 유지하는 노드이다.


![mercle2.png](image%2Fmercle2.png)


 - 위 그림에서 라이트 노드에서 마지막 값인 1e3a 해시 값과 머클 루트인 af3d 해시 값만 가진다 했을 떄, 1e3a 값에 대해 어떻게 검증하는가?를 알아보자.


![mercle3.png](image%2Fmercle3.png)



 - 풀 노드로 부터 43bc, 143c, 89fe의 정보를 받아 해시 함수에 차례대로 넣어 계산을 진행한다.
 - 검증시에 풀 노드가 머클 경로를 구하고 라이트 노드를 주는 것 입니다.
 - 1e3a가 포함된 리프 위치를 찾고, 해당 리프에서 루트까지 가는 경로에 필요한 해시들만 추출하여 전달한다.
 - 라이트 노드는 각 해시 값에 대해 검증한다.
 - 원하는 노드의 값에 대해 검증시 해시 해가며 루트까지 해시해 검증하는 것이다. 경로는 풀노드에서 받고 라이트 노드는 중간에 검증 하는 과정이다.
 - 머클 트리는 풀노드가 보유 및 생성하지만, 항상 모든 노드에 제공하는 건 아니다. 라이트 노드는 전체 트리를 갖지 않고, 필요 시 검증용 데이터만 요청한다.

출처 : https://steemit.com/kr/@brownbears/merkle-tree

---

## 질문

---

### Q. 가십 프로토콜에서 카운터로 관리하고 아래 테이블을 보면 타임도 테이블로 따로 저장하는 식으로 보이는데 성능상 안 좋아 보여서요 헬스 체크 같은 단순 값만 받아도 될 것 같은데 왜 이렇게 내부적으로 관리가 될까요??

-> 단순히 헬스 체크 값 만 받으면 네트워크 지연, 순간 장애 등으로 인해 잘못 판단할 가능성이 생기며,  상태 전파 시 최신 상태를 판단하는 근거가 부족하다. 하트비트 카운터 + 타임스탬프는 장애 판단의 정확도와 신뢰성을 높이고 분산 시스템 특유의 불확실성(비동기, 메시지 지연)을 완화한다.
가십 프로토콜 설계 시 멤버십 리스트 + 카운터 + 타임스탬프 관리는 가볍고 효율적으로 구현되어야 하며 전체 클러스터가 아주 크지 않은 한 크게 성능 저하를 일으키지 않는다. 멤버십 리스트와 메타데이터를 자주 주고받지만 각 메시지 크기가 작고, 증분 전파(deltas)를 주로 사용해 네트워크 부담을 줄이기 때문에 성능상 문제는 고려되지 않는다.

---

### Q. 머클 트리에서 중간과 루트 노드의 해시 값은 어떻게 계산 될까요? 

-> 위 설명에서 보았듯 하위 인접 노드들에 대해 해시 값을 더해서 다시 해시하는 방식 입니다. 해시함수는 보통 SHA-256을 사용합니다.

---

### Q. "반 엔트로피 프로토콜을 구현하여 사본들을 동기화 할 것이다." 여기서 말하는 사본은 힌트가 남겨진 데이터를 말하는걸까요 ?.. 아니면 동기화는 장애 유무와 상관없이 주기적으로 발생하는 것인지 궁금합니다. 단서가 남겨진 데이터들은 s2로 위임한다고 되어있는데, 위임하는 과정은 삭제하고 넘겨주는 방식인지 아니면 노드에 그대로 저장하는 방식인지 궁금해요.

-> 사본에 대한 동기화는 각 노드가 다른 데이터를 가질 떄 데이터 일관성을 맞추겠다는 의미입니다. 동기화는 장애 유무와 관련 없이 주기적으로 이루어 집니다. 힌트에 대해서는 죽은 노드에 대해 다른 노드가 힌트와 함께 데이터를 저장하게 되고 기존 죽어있던 노드가 다시 살아 났을때 힌트와 함께 데이터를 전송해 최신 노드를 유지하도록 합니다.

---

### Q. "반 엔트로피 프로토콜을 구현하여 사본들을 동기화 할 것이다." 여기서 말하는 사본은 힌트가 남겨진 데이터를 말하는걸까요 ?.. 아니면 동기화는 장애 유무와 상관없이 주기적으로 발생하는 것인지 궁금합니다. 단서가 남겨진 데이터들은 s2로 위임한다고 되어있는데, 위임하는 과정은 삭제하고 넘겨주는 방식인지 아니면 노드에 그대로 저장하는 방식인지 궁금해요.

-> 사본에 대한 동기화는 각 노드가 다른 데이터를 가질 떄 데이터 일관성을 맞추겠다는 의미입니다. 동기화는 장애 유무와 관련 없이 주기적으로 이루어 집니다. 힌트에 대해서는 죽은 노드에 대해 다른 노드가 힌트와 함께 데이터를 저장하게 되고 기존 죽어있던 노드가 다시 살아 났을때 힌트와 함께 데이터를 전송해 최신 노드를 유지하도록 합니다. 여기서 힌트는 일시적인 저장소로 죽어 있던 노드가 복구되면, 힌트를 삭제 하거나 TTL을 설정하는 경우가 있습니다.

---

### Q. 가십 프로토콜에서의 장애 감지는 해당 노드의 박동 수가 멈춰있음을 다른 노드가 알아야하는 것 같은데, 장애 노드를 제외한 모든 노드가 '장애 노드 표시'를 해야만 장애 노드로 확정이 되는 것일까요? 아니면 '쓰기/읽기 정족수' 처럼 '장애 정족수'를 두는 걸까요? 예를 들어, '장애 정족수가 3이면 3개의 노드가 1번 노드를 장애 노드로 표시하면 1번 노드는 장애 노드다.' 처럼요.

-> 가십 프로토콜에서는 장애 노드를 확정하는 데에 정확한 정족수 기준을 따르지는 않습니다. 노드별 로컬 상태에서의 실패 감지기가 일정 시간동안 하트비트를 받지 못하면 의심 상태로 만들고 십 메시지를 통해 이 의심 상태가 다른 노드로 전파되며 일정 수 이상의 노드가 동일 노드를 의심으로 간주하게 되면 시스템 수준에서 장애로 판단해 해당 노드를 장애 상태로 만듭니다. 여러 노드의 동일한 판단이 모여야만 해당 노드를 완전히 장애로 간주하기 때문에 정족수와 유사한 효과를 가진다고 할 수 있습니다.

---


### Q. 자식 노드들의 레이블로부터 계산된 해시값을 레이블로 붙여..라고 되어있는데, 자식 노드들의 레이블로 부터 해시값을 어떻게 계산하는 걸까요? 그리고 레이블 이란게 그냥 계산된 값을 적어놓은 데이터..? 라고 이해했는데 맞을까요?

-> 각 자식 노드들에 대한 해시 값을 더해 상위 노드 해시 값을 만드는 방식 입니다. 레이블이란 말이 적절한가는 모르겠지만 앞서 말씀 드린 것처럼 자식 노드의 값을 더해 해시를 계산한 값을 들고 있는 것을 말합니다. 
