

### 질문 
p.104 아래에서 3번째 문단 마지막 줄
D([s0, 1], s[s1, 2])와 D([s0, 2], s[s1, 1])는 서로 충돌 한다는데 이해가 잘 되지 않아요...

- D([s0, 1], s[s1, 1]) 버전에서 출발해서 s1 서버에서 수정된 D([s0, 1], s[s1, 2]) 와 s0 서버에서 수정된 D([s0, 2], s[s1, 1]) 데이터로 분기가 발생한 경우를 말합니다.
- 상위 버전은 같지만, 동시에 다른 서버에서 데이터 쓰기가 동작한 경우에 발생하는 문제라고 합니다.

p.104

> D([s0, 1], s[s1, 2])와 D([s0, 2], s[s1, 1]) 충돌..

모두다 작거나 크거나 (동일한건 상관없음)..! 해야하는데 그게 아니면 충돌이란 말로 이해했는데 맞을까요! (지훈님도 똑같은 질문 있으시네여)
- 네 맞습니다!

p.104 5번
데이터를 읽을 때 D3, D4 를 같이 읽는 것으로 이해했는데, 그럼 데이터를 다중화 하는 경우엔 여러 데이터 소스로부터 매번 동일한 키로 값을 읽어오는 과정을 거치게 되는 걸까요?
보통 분산을 하는 경우 해시 값으로 특정 노드에만 할당해서 데이터를 저장하게 되는 걸로 학습을 했는데... 이 경우는 어떤 케이스인 걸로 이해를 하면 좋을까요? 하나의 노드에 데이터를 저장하면서 벡터 시계로 기록을 남긴 걸로 이해를 하는 게 나을까요? 그럼 하나의 데이터를 읽을 때마다 충돌이 있는지 벡터 시계 로그를 모두 읽어 검증 작업을 매번 수행하게 되는 걸까요?
- 벡터 시계 알고리즘은 네트워크 파티션 문제, 서버 장애 등으로 인해 데이터 일관성 유지가 실패하는 경우를 고려하여 이런 경우 발생하는 데이터 충돌 문제를 해결하기 위해 동작하는 알고리즘이다.
- 다이나모 디비는 데이터 전파를 비동기적으로 수행하며, 최종적 일관성을 보장해주는 디비다.
    - 비동기적으로 수행되는 데이터 전파가 늦어지거나 실패하는 경우가 발생할 수 있다.
- 예를 들어, 업데이트가 모두 전파되지 않은 상황에서 특정 키를 담당하는 노드에 장애가 발생하고, 구 버전 데이터를 가진 노드를 통해서 추가 업데이트가 수정된 경우를 생각해보면, 이후 기존 노드가 복구되면 데이터는 2가지 버전을 갖게 될 것이다.
    - 이러한 경우에 벡터 시계를 통해 데이터 충돌을 확인하고 의미적 조정을 수행하게 될 것이다.


#### 참고) 구문적 조정과 의미적 조정
- 구문적 조정(Syntactic Reconciliation): 새로운 버전이 이전 버전을 대체하며, 시스템은 최신 버전을 결정할 수 있다. 충돌이 없이 업데이트가 수행되는 경우를 말한다.
- 의미적 조정(Semantic Reconciliation): 실패와 동시 업데이트가 발생하면, 여러 버전이 서로 충돌할 수 있으며, 이 충돌을 클라이언트가 해결해야 한다.

### 참고 자료
- https://changhoi.kim/posts/database/dynamodb-internals-1/ - 참조[4] 일부 발췌/번역한 듯
    - https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf - 참조[4] 링크