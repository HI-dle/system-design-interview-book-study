# 단일 서버, 데이터베이스

---


## 단일 서버
모든 컴포넌트가 한 대의 서버에서 실행되는 시스템으로 웹서버, 캐시 서버, DB, 등 이 시스템 구성이 하나의 서버에서 구동되는 것이다.

CDN이나 redis 같은 별도의 서버는 단일 서버의 개념 보다는 시스템 아키텍처에 포함하게 된다.



단일 서버에서 서버 시스템 구조를 알아보자.


![img.png](images/single%20server.png)

위 시스템에서의 요청 흐름을 확인하자.

1. 클라이언트는 도메인 주소를 통해 접속하게 되고 DNS에 요청하게 된다.
2. DNS는 도메인 주소를 통해 IP 주소로 변환하게 된다. 
3. 변환된 주소를 통한 서버에 HTTP 요청을 하게 된다.
4. 웹 서버는 해당하는 요청에 맞는 HTML 페이지나 JSON 형식의 데이터를 반환하게 된다. 


다음으로 단일 서버를 구성시 성능상 이슈가 될 수 있는 부분이나 주의점을 알아보자.

### 주의점이나 성능 이슈

| 항목                  | 설명                                                                                       |
|---------------------|------------------------------------------------------------------------------------------|
| 단일 장애 지점 (SPOF) | 서버 한 대에 모든 컴포넌트가 있기 때문에 하드웨어나 네트워크 장애가 발생하면 전체 시스템이 다운됨     |
| 확장성 부족           | 서버 성능(CPU, 메모리, I/O 등)의 한계에 도달하면 수평 확장이 불가능하고, 스케일 업만 가능함          |
| 리소스 경합           | 웹 서버, 애플리케이션, DB, 캐시가 같은 자원을 공유하여 CPU/메모리 경합이 발생할 수 있음             |
| 모니터링 및 진단 한계 | 모든 로직과 데이터가 한 서버에 몰려 있어 장애 발생 시 원인 추적이 어렵고 모듈별 로깅/모니터링도 어려움   |
| 성능 튜닝 범위 제한   | 웹 서버, DB, 캐시 등 각각에 맞는 성능 튜닝을 독립적으로 적용하기 어려움                            |
| 보안 취약성           | 하나의 침입으로 전체 시스템이 노출될 수 있으며, 네트워크 격리나 계층적 방어가 어려움                 |
| 백업 및 복구 어려움   | 장애 발생 시 복구할 수 있는 다른 인스턴스가 없기 때문에 백업 및 복구에 시간이 오래 걸릴 수 있음        |



### 성능 이슈

| 이슈 항목         | 주요 원인                                      | 대응 방안                                |
|------------------|-----------------------------------------------|-----------------------------------------|
| 응답 지연         | 리소스 경합, GC 문제, DB I/O 블로킹            | 캐시 사용, 비동기 처리, GC 튜닝          |
| DB 처리 병목      | 애플리케이션과 DB가 같은 자원 공유             | DB를 외부로 분리, 쿼리 최적화            |
| 메모리 부족       | JVM, DB, 캐시 등 여러 프로세스가 메모리를 공유 | 메모리 프로파일링, 메모리 분리 운영       |
| 디스크 I/O 병목   | 로그, DB, 정적 파일 등이 동일 디스크 사용       | 디스크 분리, SSD 도입                    |
| 스레드 부족       | 하나의 JVM 내에서 요청 병목                    | 스레드 풀 최적화, 비동기 처리             |



단일 서버는 빠른 MVP 개발이나 작은 규모의 프로젝트에서 고려되어 사용할만하다.

위와 같은 성능 이슈나 코드 복잡도 상에서 이유로 MSA인 다중 인스턴스 서버를 고려할 수 있다.

---

## 데이터 베이스
기본적으로 데이터 베이스는 2가지 분류로 나누어진다.

관계형 데이터 베이스인 RDBMS와 NoSQL로 나누어진다.

관계형 데이터 베이스인 RDBMS에는  대표적으로 MySql, 오라클데이터베이스, PostgreSQL 등이 있다. 관계형 데이터베이스는 자료를 테이블과 열, 컬럼으로 표현한다. SQL을 사용하며 여러 테이블에 있는 데이터를 그 관계에 따라 조인해 합칠 수 있다.

비관계형 데이터 베이스는 NoSQL이라 한다. 대표적인 것으로는 Redis, Cassandra, HIBase, AmazonDynamoDB 등이 있다.



NoSQL은 4가지 분류로 나뉠 수 있는데 키 값 저장소, 그래프 저장소, 컬럼 저장소, 문서 저장소로 나뉠 수 있다.



1. 키-값	Key → Value	빠른 조회, 단순 캐시	Redis, DynamoDB
2. 문서	JSON / BSON	유연한 스키마, 중첩 데이터 지원	MongoDB, CouchDB
3. 컬럼	컬럼 패밀리	대용량 데이터, 분석용 적합	Cassandra, HBase
4. 그래프	노드 + 엣지	관계 탐색에 강함	Neo4j, Neptune


각 구조에서 사용되는 데이터가 어떻게 사용되는지 확인해 보자.



### 키-값

`user:123 → { "name": "Alice", "age": 30 }`


### Document
````json
{
"_id": "123",
"name": "Alice",
"email": "alice@example.com",
"roles": ["user", "admin"]
}
````

### 컬럼
````
row_key: 123
name → Alice  
age → 30  
country → Korea
````


### 그래프
````
구조
(Alice) --[:FRIEND]--> (Bob)
   |
   +--[:WROTE]--> (Post: "GraphDB is cool")
                          ^
                          |
                      [:LIKES]
                          |
                        (Bob)


생성
CREATE (:User {name: "Alice", age: 25})
CREATE (:User {name: "Bob", age: 30})

관계 생성
MATCH (a:User {name: "Alice"}), (b:User {name: "Bob"})
CREATE (a)-[:FRIEND]->(b)

위 구문들은 Cypher라는 쿼리 언어를 사용합니다.
````

### NoSQL을 선택하는 상황
아주 낮은 응답 지연시간이 요구되는 상황

다루는 데이터가 비정형이라 관계형 데이터가 아닌 상황

데이터 (JSON , YAML , XML 등)를 직렬화하거나 역직렬화할 수 있기만 하면 된다.

아주 많은 양의 데이터를 저장할 필요가 있음



반대로 RDBMS를 선택해야 하는 상황은 관계형으로 데이터를 저장해야 할 경우, 영구 저장을 해야 할 경우 ACID를 모두 지켜야 할 경우이다.



## 질문

관계형DB보다 비-관계형DB가 바람직한 경우 4가지 중에 데이터(JSON, YAML, XML 등)를 직렬화하거나 역직렬화 할 수 있기만 하면 됨이 무슨 의미인걸까요? 
update는 필요없이, read, insert만 필요한 상황을 의미하는 걸까요?

이 질문에 대한 답변은 데이터 정규화나 구조에 대한 부분에 대한 거라고 생각이 듭니다! 데이터 스키마가 유연하고, 고정된 구조 없이도 저장이 가능하다는 점에서 비정형이다 보니 데이터를 직렬화와 역직렬화만 가능하게 되는 부분이기 때문과 데이터 구조 제약 없이 저장이 가능한 점에서 NoSQL에 맞기 때문이라고 생각됩니다!