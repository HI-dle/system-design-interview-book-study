## 수직적 규모 확장 vs 수평적 규모 확장

서버에 트래픽이 늘어나서 메모리가 부족해지게 되면 서버의 규모를 확장시킬 방법을 고민하게된다.
서버 규모의 확장은 수직적 규모 확장 (scale up) 과, 수평적 규모 확장 (scale out) 으로 나뉘게 된다.

### 수직적 규모 확장
> 수직적 규모 확장은 서버의 사양을 올리는 방식이다. (더 좋은 CPU, 더 많은 RAM 등)
> AWS에서 인스턴스의 사양을 올리는 것은 클릭 딸깍으로 할 수 있는 만큼 적용하기엔 가장 단순하고 간단한 방법이라는 장점이 있지만, 아래와 같은 치명적인 단점도 존재한다.
> - CPU나 메모리를 무한대로 증설할 수 없기 때문에 결국 한계에 부닥친다.(연봉올리기보다 N잡 하는것이 돈을 더 번다던.. 튜터님의 말씀이 떠올랐다.)
> - 단일 장애점(SPOF) 으로 작용하므로, 자동복구(failover)방안이나 다중화(redundancy) 방안을 제시할 수 없다. 서버에 장애가 발생하면 서비스는 완전히 중단된다.
> - 때문에 `대규모 애플리케이션`의 규모 확장에는 **수평적 규모 확장** 이 보다 적절하다.


### 수평적 규모 확장
> 수평적 규모 확장은 더 많은 서버를 추가하여 성능을 개선하는 행위를 말한다. 수평적 규모 확장인 경우에는 사용자로 부터 오는 트래픽을 여러 서버에 분산시킬 수 있는데, 이때 사용되는 것이 **부하 분산기** (Load Balancer) 이다.

## 로드 밸런서

로드밸런서는 사용자의 트래픽을 `수평적 확장`된 여러 인스턴스에 고르게 분산하는 역할을 한다.
클라이언트는 로드밸런서의 공개IP 주소를 통해 접속하게되고, 웹서버는 클라이언트의 접속을 직접 처리하지 않는다. (이 덕분에 CORS 문제를 피할 수 있다.)

![](https://velog.velcdn.com/images/hyezuu/post/21ab1c34-229f-4ffe-9dfe-ef30402cd9d6/image.png)


기본적으로는 그림과 같이 클라이언트는 공개 IP를 통해 접근하고, 로드밸런서가 클라이언트 요청을 private IP로 라우팅 해줌으로써 부하분산 뿐 아니라 보안상 이점도 얻을 수 있다.

> 사설 IP주소는 같은 네트워크에 속한 서버 사이의 통신에만 쓰일 수 있는 IP 주소로, 인터넷을 통해서는 접근할 수 없다.  실제로 유사하게 사용한 것이 AWS의 VPC (또는 이름으로 라우팅 되는 도커네트워크)가 예시가 될 수 있다.
> [# VPC, NAT 가볍게 알아보기](https://velog.io/@hyezuu/VPC-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0)

부하 분산 집합에 또 하나의 웹 서버를 추가하고 나면, 하나의 서버가 다운되더라도 로드밸런서는 헬스체크를 비정상인 인스턴스는 트래픽 라우팅 대상에서 제외**하는 방식** 을 통해 정상적인 기능을 수행하는 인스턴스로 요청을 분배할 수 있다.

추가적으로 해당 수의 인스턴스로도 트래픽을 감당할 수 없는 경우에는 추가적인 인스턴스와 해당 인스턴스로 향하는 경로를 설정해줌으로써 우아하게 대처가 가능해진다

## 데이터 베이스 다중화

>데이터베이스 역시 장애를 대비한 설계를 고려할 수 있다. 서버가 한대인 경우에서 발생하는 문제와 같이, 디스크용량이 부족해진다던가, 단일 장애점이 되어 장애 자동 복구방안을 제시할 수 없게되는 문제가 있다.
**데이터베이스 다중화** 는 이러한 문제를 해결하기 위한 기술로 사용되고 있다.

![](https://www.virtuozzo.com/application-platform-docs/database-primary-secondary-replication/01-database-primary-secondary-replication.png)

데이터 베이스 다중화는 데이터 베이스 서버간에 주 (Master) 와 부 (Slave) 관계를 설정하고, 데이터 원본은 주 서버에, 복제본은 부 서버에 저장하는 방식이다. (db replication)

![](https://velog.velcdn.com/images/hyezuu/post/86fc4435-6534-49f9-8216-e2f154661796/image.png)

- 클라이언트로부터의 쓰기 연산은 (master) 에서만 지원하도록 한다.
- 더 나은 성능 : 읽기 연산을 부 데이터베이스 서버들로 분산되어, 병렬로 처리될 수 있는 쿼리의 수가 늘어나므로 성능이 향상된다.
- 안정성 : 물리적으로 먼 거리에 DB서버를 분산시킬 수 있어 하나의 DB서버가 파괴되더라도 데이터는 보존될 수 있다.
- 고가용성 : 데이터베이스 서버에 장애가 발생하더라도 다른서버에 있는 데이터를 가져와 서비스를 제공할 수 있다.

얼마전에 배운 CQRS 와 비슷한 개념이 아닌가 했는데, DB replication은 failover에 초점을 두었다면, CQRS는 트래픽 분산에 조금더 초점을 맞춘 개념에 가까워 보인다.

서버에서 수행되는 insert, delete, update 등 데이터 쓰기 작업은 주 데이터베이스 서버에서만 업데이트된다.

>대부분의 DMBS에서 replication을 지원(DB 엔진레벨에서 구현)하고 있으며, binaryLog 기반으로 복제할 수 있다.
binaryLog 는 `statement`(redis 의 aof와 유사함)와, `row`(redis의 rdb와 유사함) 방식으로 나뉜다.
row는 데이터의 스냅샷을 기록하는 방식, statement는 명령어의 실행이력을 기록하는 방식이다.
> row 같은경우 데이터셋이 많은 경우 영향받은 데이터 셋이 전부 기록되어서 레디스와는 반대로 row 방식이 더 큰용량을 차지한다.
>레디스 같은 경우는 명령어가 키 단위로 접근해서 명령어가 더 큰용량을 차지하는듯.

[# MySQL 활용해 DB Replication 적용해보기](https://velog.io/@chlrjs132/MySQL-%ED%99%9C%EC%9A%A9%ED%95%B4-DB-Replication-%EC%A0%81%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0-Master-Slave-%EA%B5%AC%EC%A1%B0)
[DB replication](https://newwisdom.tistory.com/107)


### 장애 대응
데이터베이스 다중화시에는 DB 서버중 가운데 하나가 다운된 경우에도 대응할 수 있다
#### 부 서버 다운 : 부 서버가 한 대 뿐인 경우
- 읽기 연산은 항시적으로 모두 주 데이터베이스로 전달된다.
- 새로운 부 데이터베이스가 장애서버를 대체하게 된다.

#### 부 서버 다운 : 부 서버가 여러대인 경우
- 읽기 연산은 나머지 부 데이터베이스 서버로 분산될 것이다.
- 새로운 부 데이터베이스가 장애서버를 대체하게 된다.
####  주 서버 다운 : 부 서버가 한 대 뿐인 경우
- 해당 부 서버가 새로운 주 서버가 될 것 이다
- 모든 데이터베이스 연산은 일시적으로 새로운 주 서버상에서 수행된다
- 없는 데이터는 *복구스크립트*를 돌려서 추가해야한다.
- *다중 마스터, 원형 다중화 방식*을 도입하면 주 DB 다운시에도 데이터 일관성을 비교적 안정적으로 유지할 수 있다.

> *복구 스크립트* 란 마스터 장애 시 새로운 마스터를 선출하고 다른 서버들이 이 새 마스터와 동기화되도록 복제 설정을 재구성하는 자동화된 명령어 집합을 말한다. 일반적으로 개발자나 DBA가 직접 구성해야한다.

- 복구 스크립트 작업 예시
    - 장애 감지: 마스터 DB의 장애 상태를 감지하고 확인
    - 슬레이브 승격: 적절한 슬레이브를 선택하여 새로운 마스터로 승격
        - 읽기 전용 모드 해제
        - 슬레이브 설정 초기화
    - 복제 재구성: 다른 슬레이브들의 복제 설정을 새 마스터 정보로 업데이트
        - 복제 중지
        - 새 마스터 정보로 변경
        - 복제 재시작
    - 데이터 동기화: 마스터 장애 시점에 복제되지 않은 데이터 처리
        - 바이너리 로그/WAL 분석
        - 누락된 트랜잭션 추출 및 적용
        - 데이터 일관성 검증
    - 원본 마스터 복구: 장애가 발생했던 원본 마스터 서버 복구 후 슬레이브로 재구성
    - 
      [# 세상만사 귀찮은 MySQL DBA를 위한 자동 복구 시나리오](http://gywn.net/2017/01/automated-recovery-scenarios-for-lazy-mysql-dba/)

- 다중마스터 - active , active 구조
    - 각 DB 인스턴스들 모두가 쓰기/ 읽기 연산을 수행
    - 이 경우 충돌이 발생할 수 있다 (A 인스턴스와 B 인스턴스의 동일 행 쓰기가 다른경우)

- 원형다중화

    ![](https://velog.velcdn.com/images/hyezuu/post/c12b047b-bffc-42e9-b774-1473089273a8/image.png)

- 다중마스터와 유사한 개념이다
- 각 DB는 특정한 영역에 한해서 쓰기 작업을 수행할 수 있고, 특정 DB 에게는 Master, 또 다른 특정 DB 에게는 Slave 가 되는 구조, 꼬리물기처럼 되어있어 원형을 띄고있음
- 각 영역의 변경사항이 원형을 따라 전파되는 구조를 띄고있다.
- 다중 마스터 구조에 비해 충돌 가능성이 낮다.
- [mysql-circular-replication](https://www.jamescoyle.net/how-to/1549-mysql-circular-replication)

>Q. 특정영역에 한해서만 쓰기작업을 수행한다면 레플리카를 추가적으로 구성해야하나 ?
- **영역별 단일 장애점 문제**:
  - 각 서버가 특정 영역의 유일한 마스터 역할을 하기 때문에, 해당 서버에 장애가 발생하면 그 영역의 최신 데이터가 유실될 위험이 있다.
  - 예를 들어, A, B, C 서버가 원형으로 연결되어 있고 각각 다른 영역을 담당할 때, A 서버가 다운되면 A 영역의 최신 변경사항은 다른 서버에 완전히 복제되기 전까지 유실될 수 있다.
- **복제 지연으로 인한 문제**:
    - 원형 다중화에서 데이터 변경은 순차적으로 전파되므로, 복제 지연이 발생하면 장애 시점에 아직 전파되지 않은 변경사항은 유실된다.
    - 특히 복제 과정에서 지연이 누적될 경우 이 문제는 더욱 심각해질 수 있다.
- **추가 레플리카를 구성하는 방식을 사용하거나, 반동기 복제 방식을 활용할 수 있다.**

### 로드 밸런서와 데이터 베이스 다중화를 고려한 설계안

![](https://velog.velcdn.com/images/hyezuu/post/5094e51e-4638-486e-a62e-af8b69ae6e6c/image.png)

- 사용자는 DNS로부터 로드밸런서의 공개IP주소 를받는다.
- 사용자는 해당 IP주소를 사용해 로드밸런서에 접속한다.
- HTTP 요청은 서버1이나 서버2로 전달된다.
- 웹서버는 사용자의 데이터를 부 데이터베이스서버에서 읽는다.
- 웹서버는 데이터 변경 연산은 주 데이터베이스로 전달한다. 데이터 추가,삭제, 갱신 연산 등이 이에 해당한다.