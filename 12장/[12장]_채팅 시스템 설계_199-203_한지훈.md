# 채팅 시스템 설계

---

 - 채팅 시스템 설계의 개략적 설계안 제시 및 동의 구하기 부분 중 클라이언트와 서버의 통신 방법 부분이다.



 - 채팅 시스템의 경우 클라이언트는 모바일 앱이거나 웹 애플리케이션이고 클라이언트는 서로 직접 통신하지 않는다. 대신 각 클라이언트는 채팅 서비스와 통신을 하게 된다.

 - 채팅 서비스는 클라이언트들로부터 메시지 수신, 메시지 수신자 결정 및 전달, 수신자가 접속 상태가 아닌 경우 접속할 때까지 해당 메시지 보관을 해야 한다.

![image_12-2.png](image%2Fimage_12-2.png)

 - 위는 메시지 송수신 클라이언트와 채팅 서비스의 관계이다.

 - 채팅을 시작하려는 클라이언트는 네트워크 통신 프로토콜을 사용해 서비스에 접속하고 채팅 서비스의 경우 어떤 통신 프로토콜을 사용할 것인가도 중요한 문제이다.
 - 대부분의 클라이언트/서버 애플리케이션에서 요청을 보내는 것은 클라이언트인데, 채팅도 같다.

 - 메시지 송신 클라이언트가 요청하는 역할을 하고 송신 클라이언트는 수신 클라이언트에게 전달할 메지시를 채팅 서비스에 보낼 때 HTTP를 사용하고 수신자에게 자신의 메시지를 전달 요청한다.
 - 채팅 서비스와 접속에는 keep-alive 헤더를 사용하면 효율적인데, 클라이언트와 서버 사이 연결을 끊지 않고 계속 유지할 수 있다. 이를 통해 핸드셰이크  횟수를 줄일 수 있다. HTTP도 메시지 전송 프로토콜로 사용하기 좋은 선택이지만 메시지 수신 시나리오는 복잡하다. HTTP는 클라이언트가 연결을 만드는 프로토콜이고 서버에서 클라이언트로 임의 시점에 메시지를 보내는데 쉽게 쓰일 수 없다. 서버가 연결을 만드는 것처럼 동작할 수 있도록 많은 기법이 있다.

---

 ## 폴링 방식

![폴링.png](image%2F%ED%8F%B4%EB%A7%81.png)

 - 위와 같이 주기적으로 클라이언트가 서버에 요청을 보내는 방식으로 새 데이터가 없어도 서버는 응답을 한다.

 - 불필요한 요청 증가로 서버 트래픽 발생과 요청과 응답 사이 지연이 발생하게 된다.


## 롱 폴링 방식

![롱폴링.png](image%2F%EB%A1%B1%ED%8F%B4%EB%A7%81.png)
 
 - 폴링 방식을 개선한 것으로 동일하게 클라이언트가 서버에게 요청하지만 서버는 새 데이터가 없다면 일정 시간 동안 응답하지 않고 새 데이터가 있을 때까지 대기하고 반환한다. 하지만 너무 긴 연결은 서버 자원을 소모하기 때문에 timeout을 설정한다.

 - 데이터가 없다면 time out을 반환하고 다음 요청에 데이터가 있다면 반환한다. 
 - 폴링에 비해 불필요한 요청은 줄어들지만 역시 불필요한 요청은 발생하고 요청과 응답 사이 지연은 발생한다.

 - 약점
   - 메시지를 보내는 클라이언트와 수신하는 클라이언트가 같은 채팅 서버에 접속하게 되지 않을 수 있다. HTTP 서버들은 보통 무상태 서버로 로드밸런싱을 위해 라운드 로빈 알고리즘을 사용하는 경우 메시지를 받은 서버는 해당 메시지를 수신할 클라이언트와의 롱 폴링 연결을 가지고 있지 않은 서버일 수 있다.
   - 서버 입장에서 클라이언트가 연결을 해제했는지 아닌지 알 좋은 방법이 없다.


## 서버 센트 이벤트 방식

![서버센트이벤트.png](image%2F%EC%84%9C%EB%B2%84%EC%84%BC%ED%8A%B8%EC%9D%B4%EB%B2%A4%ED%8A%B8.png)

 - 이 방식은 클라이언트는 최초 한 번 서버에 연결을 요청하고 새 데이터가 생길 때마다 서버가 처리해 클라이언트에게 응답을 보낸다.

 - 이 방식은 HTTP 통신을 종료하지 않고 연결을 유지하는 방식이다.

 - SSE(server-sent event)를 사용해 실시간으로 클라이언트에게 응답을 보네며 이벤트 기반으로 서버에서 보낸 메시지에 대해 이벤트 처리가 가능하다.

 - 연결이 끊어진 경우 SSE는 자동으로 재연결을 시도한다. 하지만 이 방식은 클라이언트 최초 요청 이후 서버만 일방적으로 응답한다.

 - 단방향 통신만 가능하며 모바일/불안정한 네트워크에 약하고 서버가 클라이언트 수만큼 연결을 유지해야 하기 때문에 대규모 연결 확장에 불리하며 보안 기능에 제한이 있다.

 - 종료 방식은 클라이언트 측에서 브라우저 종료시나 별도 종료 이벤트 발생 시키거나 해야 한다. 서버가 종료하는 경우는 HTTP 연결 종료나 response를 닫아야 한다.

 - 이 방식들은 실시간 통신을 구현하기 위한 방법으로 완벽한 실시간 통신을 보장하진 않는다.


## 웹 소켓 방식

![웹소켓.png](image%2F%EC%9B%B9%EC%86%8C%EC%BC%93.png)

 - 웹 소켓(Web Socket)은 웹 브라우저와 서버 간 실시간 양방향 통신을 가능하게 하는 프로토콜로 HTTP와 달리 지속적 연결을 유지해 데이터를 주고받을 수 있기 때문에 양방향 통신에서 클라이언트와 서버가 데이터를 주고받을 때 사용한다.
 - 주요 특징
   - 지속적인 연결 : HTTP처럼 요청/응답 방식이 아닌 연결이 유지되는 동안 실시간으로 데이터를 주고 받는다.

   - 실시간성 : 빠른 데이터 전송이 필요한 채팅, 게임, 주식 정보 등 실시간 애플리케이션에 적합하다.

   - TCP 기반 : 웹 소켓은 TCP 기반으로 동작한다.

 - 장점으로는 실시간 데이터 전송, 연결 유지 비용이 낮기 때문에 높은 효율성, 다양한 용도로 채팅, 실시간 게임, 주식 거래, 협업 도구 등에 사용한다.

 - 단점으로는 지속적인 연결로 인한 서버 부하 발생, HTTP 보다 어려운 구현으로 복잡성 증가와 HTTPS와 유사한 wss 프로토콜을 통한 보안이 필요하다.


 - 웹 소켓은 HTML5에 등장한 실시간 웹 애플리케이션을 위해 설계된 통신 프로토콜로 TCP를 기반으로 동작한다.

 - TCP를 기반으로 한 웹 소켓은 신뢰성 있는 데이터 전송을 보장하고 순서가 보장된 양방향 통신을 제공한다.

 - 클라이언트와 서버가 최초 연결이 이루어지면 이 연결을 통한 양방향 통신을 지속적으로 할 수 있다.

 - 여기서 지속적 연결은 클라이언트와 서버가 지속적으로 데이터를 주고받을 수 있는 것이다.

 - 이때 데이터는 패킷(packet) 형태로 전달된다.



 - 웹소켓은 HTTP 기반으로 초기 핸드셰이크(hand Shake)를 수행하고 이후 데이터 전송은 웹 소켓 프로토콜 통해 통신하게 된다.

 - 클라이언트에서 요청을 하면 서버 측에서 응답으로 101 Switching Protocols 상태 코드를 응답한다. 

---

 - 확인하고 나면 메시지 송수신시 웹 소켓을 사용하는 것을 확인할 수 있다. 웹 소켓을 이용하면 메시지를 보낼 때나 받을 때 동일한 프로토콜을 사용할 수 있으므로 설계뿐만 아닌 구현도 단순하고 직관적이다. 유의할 점은 웹소켓 연결은 항구적으로 유지되어야 하기 때문에 서버 측에서 연결 관리를 효율적으로 해야 한다.

---

## 질문
 - p. 200 중간쯤
 - 채팅 서비스와의 접속에는 keepalive 헤더를 사용하면 효율적인데, 클라이언트와 서버 사이의 연결을 끊지 않고 계속 유지할 수 있어서다. TCP 접속 과정에서 발생하는 핸드셰이크(handshake) 횟수를 줄일 수 있음은 물론이다.
 - 라는데 keep-alive 헤더를 사용하면 왜 효율적일까요? 핸드세이크 횟수는 어떻게 줄일 수 있나요?


---

## 답변
 - HTTP 연결 리소스 절약 중 하나로 keep-alive를 지원하는 게 있습니다.
 - keep-alive는 설정하면 연결을 유지한 채 추가 요청을 처리 가능합니다. 네트워크 리소스를 절약하고 응답 속도 개선 가능하게 됩니다.

````
//클라이언트 요청
Connection: keep-alive

//서버 응답
Connection: keep-alive
Keep-Alive: timeout=5, max=100

timeout=5: 연결을 최대 5초까지 유지
max=100: 최대 100개의 요청까지 재사용 가능
````
 - 위와 같은 형식으로 헤더에 담아 요청과 응답이 발생하고 효과로는 TCP 연결 재활용 → 3-way handshake, TLS 핸드셰이크 생략 가능, 연결 수 줄어들어 서버/네트워크 리소스 효율적 사용 가능합니다.
 - 주의점은 연결을 오래 유지하므로 서버의 연결 수가 많아지면 리소스 소모와 과도한 keep-alive는 오히려 병목 초래할 수 있습니다.


---

## 질문

 - p. 203 웹소켓 그림 밑
   처음에는 http 연결이지만 특정 핸드세잌크 절차를 거쳐 웹소켓 연결로 업그레이드 된다. 는데 웹소켓은 http를 기본적으로 사용하는 건가요? 저 과정이 궁금하네요!

---

## 답변

- 웹 소켓 설명에서 어느정도 해소가 되었을거라 생각합니다. 웹 소켓 연결시 HTTP로 클라이언트와 서버가 연결하게 되고 이후 TCP를 통한 실시간 통신이 이루어지게 됩니다.
> 웹 소켓 사용시 HTTP로 먼저 연결을 하는 것으로 하는데 다른 방식으로 연결하거나 HTTP 사용하지 않을 수 있는지 찾아 보았는데 웹 소켓은 반드시 HTTP를 시작점으로 사용해야 합니다.
---

## 질문

 - p.202 밑에서 네번째줄부터
 -  라운드 로빈 알고리즘을 사용하는 경우, 메시지를 받은 서버는 해당 메세지를 수신할 클라이언트와의 롱 폴링 연결을 가지고 있지 않은 서버일 수 있다.. 부분이 이해가 잘 안갑니다..
---

## 답변
 - 우선 위 설명이 롱 폴링에만 한정되지 않습니다. 폴링(Polling), 롱 폴링(Long Polling), 서버 센트 이벤트(Server-Sent Events, SSE) 등 HTTP 기반의 모든 통신 방식에서 발생할 수 있는 공통적인 문제입니다.
 - 채팅 시스템이고 무상태를 유지하는 전제가 있고 A와 B가 메시지를 서로 송수신 한다면 같은 서버나 채널을 사용해야 합니다.
 - 사용자가 라운드 로빈을 통해 각 다른 서버에 접속한다면 송수신이 제대로 이루어지지 않습니다.
 - 이를 해결하기 위해서는 별도의 메시징 시스템, 세션 동기화 저장소, 스티키 세션등 메시지나 서버를 동기화할 수 있는 방법이 필요하게 됩니다.