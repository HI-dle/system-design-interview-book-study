## 처리율 제한 알고리즘
### 이동 윈도 로깅 알고리즘

#### 특징 및 동작 방식
> 고정 윈도 카운터 알고리즘의 트래픽 집중시, 요청 처리율을 넘어서는 문제 보완
- 요청의 타임스탬프를 추적한다 타임스탬프 데이터는 보통 레디스의 Sorted Set 같은 캐시에 보관한다.
- 새 요청이 오면 만료된 타임스탬프는 제거한다. 만료된 타임스탬프는 현재 윈도의 시작지점 이전의 것을 말한다.
- 새 요청의 타임스탬프를 로그에 추가한다.
- 로그의 크기가 허용치보다 같거나 작으면 요청을 시스템에 전달한다. 그렇지 않으면 처리를 거부한다 (429)

![](image/sliding_window_logging.png)

>분 당 2회의 요청만을 처리하도록 설정되었다.

- 1:00:01
  - 로그 추가 후 윈도우의 크기 == 1 (허용)
- 1:00:30
  - 로그 추가 후 윈도우의 크기 == 2 (허용)
- 1:00:50
  - 로그 추가 후 윈도우의 크기 == 3 (거부)
- 1:01:40
  - 로그 추가 후 윈도우의 크기 == 2 (허용)
- 1:01:45
  - 로그 추가 후 윈도우의 크기 == 3 (거부)

#### 장점
-  알고리즘 처리율 제한 메커니즘이 아주 정교하여, 어느 순간의 윈도를 보더라도 허용되는 요청의 개수는 시스템의 처리율 한도를 넘지 않는다.
#### 단점
- 모든 요청의 타임스탬프를 보관하기 때문에 다량의 메모리를 사용한다

-----
## 질문 

- p63~64
  이동 윈도 로깅 알고리즘 예시에서 1:01:40 에 도착한 요청은 시스템에 전달되는 것을 이해했습니다.
  그런데 1:01:45 에 새로운 요청이 추가적으로 발생한다면, 이 요청은 시스템에 전달되지 않게 되는 걸까요?
  큐에 1:00:50과 1:01:40 로그가 존재하는 것으로 이해가 되었거든요.
  더해서 만약 1:01:50 이 되어서 1:00:50이 제거되고(확실치 않음) 다른 요청 1:01:55 가 들어온다면 이 요청은 처리될 수 있을까요?
  왜냐하면 큐에는 여전히 1:01:40 과 1:01:45 로그가 있을 거니까요.

혹은 각 요청들이 처리되었는지 아닌지를 따로 저장해서 체크하거나, 처리가 되지 않은 요청은 기록을 하지 않아야 하는 게 아닌가 하는 생각이 듭니다... 다른 분들 의견이 궁금합니다.

