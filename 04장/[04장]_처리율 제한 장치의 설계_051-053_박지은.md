# 처리율 제한 장치의 설계

> 네트워크 시스템에서의 **처리율 제한 장치(rate limiter)**: 클라이언트 또는 서비스가 보내는 트래픽의 처리율(rate)을 제어하기 위한 장치

- 예시
  - HTTP
     - 특정 기간 내에 전송되는 클라이언트의 요청 횟수를 제한
     - API 요청 횟수가 제한 장치에 정의된 임계치(threshold)를 넘어서면 추가로 도달한 모든 호출은 처리가 중단(block)된다.
       > 사례 
       > - 사용자는 **초당** **2회 이상** 새 글을 올릴 수 없다. 
       > - 같은 IP 주소로는 **하루**에 **10개 이상**의 계정을 생성할 수 없다. 
       > - 같은 디바이스로는 **주당** **5회 이상** 리워드(reward)를 요청할 수 없다.

## 처리율 제한 장치의 장점
- DoS(Denial of Service) 공격에 의한 자원 고갈(resource starvation) 방지
  - 처리율 제한 장치는 추가 요청에 대해서 처리를 중단함으로써 DoS 공격을 방지한다.
    >   사례 
    >   - 트위터는 3시간 동안 300개의 트윗만 올릴 수 있도록 제한
    >   - 구글 독스(Google docs) API는 사용자당 분당 300회의 read 요청만 허용
- 비용 절감
  - 추가 요청에 대한 처리를 제한하면 서버를 많이 두지 않아도 되고, 우선순위가 높은 API에 더 많은 자원을 할당 가능
    > 제3자(third-party) API 사용료를 지불하고 있는 회사들은 처리율 제한이 더욱 중요 
    > 
    > API 과금이 호출 횟수에 따라 이루어진다면, 횟수를 제한하여 비용을 절감할 수 있다.
    > - ex. 신용 확인, 신용카드 결제, 건강 상태 확인 
- 서버 과부하 막음
  > ex. 봇(bot)에서 오는 트래픽, 사용자의 잘못된 이용 패턴으로 유발된 트래픽을 걸러낼 수 있다.

## 1단계. 문제 이해 및 설계 범위 확정

- 처리율 제한 장치를 구현할 때, **여러 가지 알고리즘**을 사용할 수 있다.
  - 각각은 고유한 장점이 있으므로, 어떤 제한 장치를 구현해야 하는지 **요구사항에 대한 이해가 필요**하다.

### 요구사항 이해하기
처리율 제한 장치를 효과적으로 설계하려면 다음과 같은 항목들을 사전에 고려해야 한다.
- 제한 장치의 위치
  - 어떤 위치에서 제한을 적용할 것인가? 
    - 클라이언트 측 제한: 앱이나 프론트엔드에서 요청 제한 
    - 서버 측 제한: API 서버 또는 API Gateway에서 제한
- 제어 기준
  - 어떤 기준으로 요청을 식별하고 제한할 것인가?
    - IP 주소
    - 사용자 ID
    - API 키
    - 엔드포인트별 요청 제한
    - 사용자 등급별 제한
    - 다양한 제어 규칙을 지원하는 유연한 정책 시스템 필요
- 시스템 규모
  - 적용 대상 시스템은 어느 정도의 트래픽을 처리해야 하는가?
    - **소규모 시스템**: 단일 인스턴스 기반 설계 가능
    - **대규모 시스템**: 고성능, 고확장성 구조 필요
- 분산 환경 필요 여부
  - **여러 서버/인스턴스 간 처리율 제한 상태를 공유**해야 하는가?
    - 필요 시 **분산형 처리율 제한(Distributed Rate Limiting)** 구현 필요
      - Redis, 분산 캐시 등 외부 저장소 필요
- 통합 방식
  - 제한 장치를 어떤 방식으로 시스템에 통합할 것인가?
    - **독립된 마이크로서비스**
    - **애플리케이션 내부 모듈/라이브러리**
    - **API Gateway 플러그인** 
- 사용자 알림
  - 요청이 제한되었을 때, 사용자에게 이를 알려야 하는가?
    - 예: `HTTP 429 Too Many Requests` 응답
    - 제한 사유 및 재시도 가능 시간 등 포함 가능

> #### 요구사항 요약 정리
> 
> * 설정된 처리율 초과 요청은 **정확하게 제한**되어야 한다.
>   ➡️ 제어 기준
> * **낮은 응답시간** 유지: 제한 장치가 성능 저하를 유발해서는 안 된다.
>   ➡️ 시스템 규모, 통합 방식
> * **메모리 효율성**: 가능한 적은 메모리로 작동해야 한다.
>   ➡️ 분산 환경 필요 여부
> * **분산 환경 대응**: 여러 서버 간 상태 공유 가능해야 한다.
>   ➡️ 분산 환경 필요 여부
> * **명확한 예외 처리**: 요청 제한 시 사용자에게 **명확한 피드백** 제공
>   ➡️ 사용자 알림
> * **결함 감내성(Fault Tolerance)**: 제한 장치 장애 시에도 전체 시스템은 정상 작동해야 한다.
>   ➡️ 통합 방식, 분산 환경 필요 여부

## 질문
p.53 첫 단락
처리율 제한 장치는 클라이언트와 서버에서 구현 될 수 있을 것 같은데 각각 어떤 방식으로 구현될 수 있을까요? 
뒤에 조금 더 읽어보니 게이트웨이 같은 곳에서 처리율 초과시 차단을 하던데 
각 사용자마다 별도 저장 공간으로 초과된 처리율을 저장해서 관리하는지 
이런 코드 레벨이 아닌 어떤 방식으로 하는지 궁금합니다.

| 위치                | 구현 예시                               | 구현 방식                                                      | 상태 저장 방식                 | 장점                           | 단점                                                                            |
|-------------------| ----------------------------------- | ---------------------------------------------------------- | ------------------------ |------------------------------|-------------------------------------------------------------------------------|
| **클라이언트**         | 모바일 앱, 브라우저, SDK                    | - UI 제어<br>- 내부 타이머 기반 차단<br>- 429 응답 후 백오프                | 로컬 상태 (메모리 등)            | - 빠른 응답<br>- 서버 트래픽 감소       | - 신뢰 불가(위변조가 쉽다)<br>- 서버 보호 불가(모든 클라이언트의 구현을 통제하기 어렵다)                                              |
| **서버 애플리케이션**     | Spring Filter, Express Middleware 등 | - 요청 시 사용자 ID/IP 기준 카운트 증가<br>- 시간 창 기준 제한<br>- Redis 등 사용 | - Redis<br>- Local Cache | - 유연한 정책 설정(자유롭게 처리율 제한 알고리즘을 선택)<br>- 신뢰 가능     | - 성능/자원 소비<br>- 복잡도 증가                                                        |
| **API Gateway(미들웨어측)** | Spring Cloud Gateway, Kong, Envoy 등 | - 정책 기반 처리<br>- Redis와 연동된 플러그인 사용                         | - Redis<br>- 외부 저장소      | - 분산 처리 적합<br>- 시스템 외부 구성 가능 | - 정책 커스터마이징 한계<br>- 외부 구성 필요<br>- SPOF : 미들웨어에 문제 생기면 전체 처리율 제한 처리에도 문제가 생긴다. |

### 처리율 제한 라이브러리 - [참고](https://hogwart-scholars.tistory.com/entry/Spring-Boot-%EC%9E%90%EB%B0%94-%EC%8A%A4%ED%94%84%EB%A7%81%EC%97%90%EC%84%9C-%EC%B2%98%EB%A6%AC%EC%9C%A8-%EC%A0%9C%ED%95%9C-%EA%B8%B0%EB%8A%A5%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-4%EA%B0%80%EC%A7%80-%EB%B0%A9%EB%B2%95#RateLimitJ-1)
- Bucket4j
  - [github](https://github.com/bucket4j/bucket4j)
  - Bucket4j: 토큰 버킷 알고리즘을 기반으로 하는 Java 기반의 처리율 제한 라이브러리
- guava 
  - [github](https://github.com/google/guava)
  - 구글이 개발한 오픈소스 라이브러리
- RateLimitJ
  - [github](https://github.com/mokies/ratelimitj)
- Resilience4j
  - [공식문서](https://resilience4j.readme.io/)